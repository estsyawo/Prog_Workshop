for(l in 1:k){
mS[j,l]=Sig[(j-1)*k + l]
}
}
dim(mS)
dim(X)
k=kstar+1
Sig0 = rep(0,(p+1)*k)
# starting values:
for(j in 1:p){
#for(l in 1:k){
Sig0[((j-1)*k + 1):(j*k)][sample(1:k,1)]<- 1
#}
}
sum(Sig0)
k=kstar+1
Sig0 = rep(0,(p+1)*k)
# starting values:
for(j in 1:(p+1)){
#for(l in 1:k){
Sig0[((j-1)*k + 1):(j*k)][sample(1:k,1)]<- 1
#}
}
sum(Sig0)
k=3+1
p=ncol(cbind(1,X))
mS<- matrix(NA,(p+1),k)
for(j in 1:p){
for(l in 1:k){
mS[j,l]=Sig[(j-1)*k + l]
}
}
tk=X%*%mS
dim(tk)
dim(X)
Xm = cbind(1,X)
p=ncol(Xm)
p
p
k
mS<- matrix(NA,p,k)
for(j in 1:p){
for(l in 1:k){
mS[j,l]=Sig[(j-1)*k + l]
}
}
dim(Xm)
dim(mS)
tk=Xm%*%mS
dim(tk)
err=(Y-tk%*%solve(t(tk)%*%tk)%*%t(tk)%*%Y)
dim(err)
t(err)%*%err
any(is.na(err))
any(is.na(tk))
dim(X)[2] +1
p=dim(X)[2] +1
(p=dim(X)[2] +1)
(k=kstar+1)
Sig0 = rep(0,p*k)
length(Sig0)
Sig=Sig0
k=3+1
Xm = cbind(1,X)
p=ncol(Xm)
mS<- matrix(NA,p,k)
for(j in 1:p){
for(l in 1:k){
mS[j,l]=Sig[(j-1)*k + l]
}
}
#mS=t(mS)
tk=Xm%*%mS
any(is.na(tk))
if(any(is.na(tk))){stop("Check data or starting values for NA")}
err=(Y-tk%*%solve(t(tk)%*%tk)%*%t(tk)%*%Y)
t(err)%*%err
dim(t(tk)%*%tk)
t(tk)%*%tk
Sig0 = rep(0,p*k)
# starting values:
for(j in 1:(p+1)){
#for(l in 1:k){
Sig0[((j-1)*k + 1):(j*k)][sample(1:k,1)]<- runif(1)
#}
}
sum(Sig0)
p
k
runif(4)
Sig0 = rep(NA,p*k)
# starting values:
for(j in 1:p){
#for(l in 1:k){
Sig0[((j-1)*k + 1):(j*k)]<- runif(4)
#}
}
sum(Sig0)
Sig0=Sig0*p/(sum(Sig0))
sum(Sig0)
Sig=Sig0
k
Xm = cbind(1,X)
p=ncol(Xm)
p
mS<- matrix(NA,p,k)
for(j in 1:p){
for(l in 1:k){
mS[j,l]=Sig[(j-1)*k + l]
}
}
any(is.na(mS))
tk=Xm%*%mS
if(any(is.na(tk))){stop("Check data or starting values for NA")}
err=(Y-tk%*%solve(t(tk)%*%tk)%*%t(tk)%*%Y)
t(err)%*%err
Sigfn<- function(Sig){
k
Xm = cbind(1,X)
p=ncol(Xm)
mS<- matrix(NA,p,k)
for(j in 1:p){
for(l in 1:k){
mS[j,l]=Sig[(j-1)*k + l]
}
}
# any(is.na(mS))
# mS=t(mS)
tk=Xm%*%mS
if(any(is.na(tk))){stop("Check data or starting values for NA")}
err=(Y-tk%*%solve(t(tk)%*%tk)%*%t(tk)%*%Y)
t(err)%*%err
}
Sigfn(Sig = Sig0)
ans1<- optim(par = Sig0,fn=Sigfn)
ans1
library(BB)
ansBB<- BBoptim(par = Sig0,fn=Sigfn)
ansBB$par
round(ansBB$par,4)
mS<- matrix(NA,p,k)
length(ansBB$par)
p*k
mS<- matrix(NA,p,k)
for(j in 1:p){
for(l in 1:k){
mS[j,l]=ansBB$par[(j-1)*k + l]
}
}
any(is.na(mS))
summary(ansBB)
ansBB
Xm = cbind(1,X)
tk=X%*%mS; del = solve(t(tk)%*%tk)%*%tk%*%Y
Xm = cbind(1,X)
dim(Xm)
dim(mS)
tk=Xm%*%mS
solve(t(tk)%*%tk)
solve(t(tk)%*%tk)%*%tk%*%Y
solve(t(tk)%*%tk)%*%t(tk)%*%Y
del = solve(t(tk)%*%tk)%*%t(tk)%*%Y
(del = solve(t(tk)%*%tk)%*%t(tk)%*%Y)
table(bets)
round(ansBB$par,4)
sum(ansBB$par)
set.seed(14);(bets<- sample(-1:2,11,replace = TRUE))
table(bets); kstar=length(unique(bets))
set.seed(14);X = matrix(runif(1000,-2,4.5),ncol = 10); (p=dim(X)[2] +1)
Y = cbind(1,X)%*%matrix(bets); length(Y)
(k=kstar+1)
Sig0 = rep(NA,p*k)
for(j in 1:p){
#for(l in 1:k){
Sig0[((j-1)*k + 1):(j*k)]<- runif(4,-1,1)
#}
}
Sig0=Sig0*p/(sum(Sig0))
sum(Sig0)
Sigfn(Sig = Sig0)
ansBB<- BBoptim(par = Sig0,fn=Sigfn)
round(ansBB$par,4); sum(ansBB$par)
mS<- matrix(NA,p,k)
for(j in 1:p){
for(l in 1:k){
mS[j,l]=ansBB$par[(j-1)*k + l]
}
}
any(is.na(mS)) #checking
Xm = cbind(1,X)
tk=Xm%*%mS;
(del = solve(t(tk)%*%tk)%*%t(tk)%*%Y)
table(bets)
dim(mS)
dim(del)
(bel = mS%*%del)
bets
round(c(bel),3)
bets
Sigfn(Sig = Sig0)
ansBB<- BBoptim(par = Sig0,fn=Sigfn)
round(ansBB$par,4)
sum(ansBB$par)
mS<- matrix(NA,p,k)
for(j in 1:p){
for(l in 1:k){
mS[j,l]=ansBB$par[(j-1)*k + l]
}
}
any(is.na(mS))
Xm = cbind(1,X)
tk=Xm%*%mS;
(del = solve(t(tk)%*%tk)%*%t(tk)%*%Y)
(bel = mS%*%del)
bets
round(c(bel),3)
library(BB)
p=31
set.seed(14);(bets<- sample(-1:2,p,replace = TRUE))
table(bets); kstar=length(unique(bets))
set.seed(14);X = matrix(runif(1000,-2,4.5),ncol = (p-1)); #(p=dim(X)[2] +1)
Y = cbind(1,X)%*%matrix(bets); length(Y)
(k=kstar+1)
# k=9
Sig0 = rep(NA,p*k)
# starting values:
for(j in 1:p){
#for(l in 1:k){
Sig0[((j-1)*k + 1):(j*k)]<- runif(k,-1,1)
#}
}
any(is.na(Sig0))
Sig0=Sig0*p/(sum(Sig0))
sum(Sig0)
# Sig=Sig0
Sigfn<- function(Sig){
Xm = cbind(1,X)
p=ncol(Xm)
mS<- matrix(NA,p,k)
for(j in 1:p){
for(l in 1:k){
mS[j,l]=Sig[(j-1)*k + l]
}
}
# any(is.na(mS))
# mS=t(mS)
tk=Xm%*%mS
if(any(is.na(tk))){stop("Check data or starting values for NA")}
err=(Y-tk%*%solve(t(tk)%*%tk)%*%t(tk)%*%Y)
t(err)%*%err
}
Sigfn(Sig = Sig0)
ansBB<- BBoptim(par = Sig0,fn=Sigfn)
round(ansBB$par,4); sum(ansBB$par)
mS<- matrix(NA,p,k)
for(j in 1:p){
for(l in 1:k){
mS[j,l]=ansBB$par[(j-1)*k + l]
}
}
any(is.na(mS)) #checking
Xm = cbind(1,X)
tk=Xm%*%mS;
(del = solve(t(tk)%*%tk)%*%t(tk)%*%Y)
(bel = mS%*%del)
table(bets)
rbind(bets,round(c(bel),3))
library(Rcpp)
NumericVector timesTwo(NumericVector x) {
return x * 2;
}
timesTwo(42)
#include <Rcpp.h>
using namespace Rcpp;
// This is a simple example of exporting a C++ function to R. You can
// source this function into an R session using the Rcpp::sourceCpp
// function (or via the Source button on the editor toolbar). Learn
// more about Rcpp at:
//
//   http://www.rcpp.org/
//   http://adv-r.had.co.nz/Rcpp.html
//   http://gallery.rcpp.org/
//
// [[Rcpp::export]]
NumericVector timesTwo(NumericVector x) {
return x * 2;
}
// You can include R code blocks in C++ files processed with sourceCpp
// (useful for testing and development). The R code will be automatically
// run after the compilation.
//
/*** R
timesTwo(42)
*/
dj<- matrix(runif(16),ncol = 4)
dj
dj<- matrix(runif(28),ncol = 4)
dim(dj)
dj%*%t(dj)
diag(dj%*%t(dj))
devtools::install_github("jimhester/lookup")
insstall.packages("devtools")
install.packages("devtools")
install.packages("pryr")
library("pryr")
show_c_source(solve)
getAnywhere(solve)
library(lookup)
devtools::install_github("jimhester/lookup")
lookup(solve)
library(lookup)
lookup(solve)
lookup(qr)
zfn=function(x) log(x^2) + 4/(x^2)
curve(zfn,0.001,5)
zfn(2)
curve(zfn,0.1,5)
optimise(zfn,c(0.1,5))
install.packages("glmnet")
setwd("~/Dropbox/Prog_Codes/Prog_Workshop/Session_1")
getwd()
setwd("C:/Users/Marcus/Dropbox/Prog_Codes/Prog_Workshop/Session_1")
x=0
n=0
set.seed(333)
# set seed when using random number generation for reproducibility of results
while (x <= 10) {
n=n+1
x=x+rnorm(1,mean=.5,sd=1)
}
print(paste ("n = ", n, ", x = ",round(x,2) )) #print out results
while(x <= 10) {
n=n+1
x=x+rnorm(1,mean=.5,sd=1)
}
df = 0
x = -2
fx1 = -(x-1)^2
while(df>=0){
x = x + 0.001
fx2 = -(x-1)^2
df = fx2-fx1
fx1=fx2
}
x
df = 0
x = -2
fx1 = -(x-1)^2
n = 0
while(df>0){
n=n+1
x = x + 0.001
fx2 = -(x-1)^2
df = fx2-fx1
fx1=fx2
}
x
n
df = 10
x = -2
fx1 = -(x-1)^2
n = 0
while(df>0){
n=n+1
x = x + 0.001
fx2 = -(x-1)^2
df = fx2-fx1
fx1=fx2
}
x
n
df = 10
x = -2
fx1 = -(x-1)^2
n = 0
while(df>0){
n=n+1
x = x + 0.001
fx2 = -(x-1)^2
df = fx2-fx1
fx1=fx2
}
x-0.001
n-1
powers = function(x) {
matrix(c(x,x^2,x^3),nrow=length(x),ncol=3)
}
vv = 1:5
powers(vv)
CDP = function(K,L) (K^0.4) * (L^0.6)
CDP(200,40)
?curve
curve(f,-2,5)
f = function(x) -(x-1)^2
curve(f,-2,4)
#--------------------------------------------->
# A complicated example:
# A function to compute OLS results
OLS<- function(y,x){
N = length(y) #obtain number of observations
y = matrix(y,ncol = 1) # a matrix of column length 1
x = as.matrix(cbind(1,x)) # include 1's for the intercept term
k=ncol(x) # number of parameters to estimate
beta = solve(t(x)%*%x)%*%t(x)%*%y # obtain parameters (k x 1 vector)
res = y - x%*%beta # compute residuals
df = N - k  #degree of freedom
sig = sum(res^2)/df #compute sigma squared
varcov<- sig*solve(t(x)%*%x) # compute variance-covariance matrix
m = matrix(NA,nrow = 4,ncol = k) # a matrix to store regresion results
m[c(1,2),] = rbind(t(beta),sqrt(diag(varcov))) # first two rows to store parameters
# and standard errors
t.stat = m[1,]/m[2,] # compute t statistics
pval = 2*(1-pt(abs(t.stat),df)) #p values taken from the t distribution
m[c(3,4), ] <- rbind(t.stat,pval) # store t-stats and p-values in 3rd and 4th rows
dimnames(m)[[1]]<- c("estimate", "std. error","t stat","p value")
# label the rows
return(t(m))
}
dat<- read.csv("dat.csv",header = T,sep = " ")
names(dat); dim(dat) # check column names and dimension of matrix
nr = dim(dat)[[1]] # extract number of rows
nc = dim(dat)[[2]] # extract number of columns
nr
nc
#--------------------------------------------->
## Manipulating the data set
# create a matrix of two columns age and experience
xx = as.matrix(cbind(dat$age,dat$experience))
reg<-OLS(y=dat$nonwife,x=xx)
reg
reg
regI<- lm(dat$nonwife~xx)
summary(regI)
reg # for comparison
like<- function(y,x,pars){
N = length(y) #obtain number of observations
y = matrix(y,ncol = 1) # a matrix of column length 1
x = as.matrix(cbind(1,x)) # include 1's for the intercept term
k=ncol(x) # number of parameters to estimate
np = length(pars) #obtain number of parameters (including sigma)
beta = matrix(pars[-np],ncol = 1) #obtain column vector of parameters
sig = pars[np]
res<- y - x%*%beta
ll = sum(dnorm(res,sd=sqrt(sig),log = T)) #obtain log joint likelihood
return(ll)
}
like(y=dat$nonwife,x=xx,pars = rep(1,4))
like(y=dat$nonwife,x=xx,pars = reg[1,])
piecefn<- function(x){
if(x<0){
y=-x^4
}else if(x>2){
y=(x-2)^3
}else{
y = 0
}
return(y)
}
piecefn=Vectorize(piecefn)
curve(piecefn,from = -4,to=10)
piecefn(-3)
piecefn(1)
piecefn(2.4)
(x = runif(10))
?runif
set.seed(40) ; (x = runif(10))
set.seed(40) ; x = rnorm(10000,mean=1,sd=2)
plot(density(x), main = "kernel density plot of x~N(1,2)")
set.seed(40)
z = rbeta(1000,shape1 = 1, shape2 = 4)
plot(density(z),main = "kernel density plot of z~beta(1,4)")
library("AER")
install.packages("AER")
library("AER")
dat<- read.csv("dat.csv",header = T,sep = " ") # load data set
reg1<- lm(dat$nonwife~dat$age + I(dat$age^2)+dat$education+dat$experience)
summary(reg1)
?lm
summary(reg1)
data("Journals",package = "AER")
names(Journals)
journals <- Journals[, c("subs", "price")]
journals$citeprice <- Journals$price/Journals$citations # generate new
summary(journals)
plot(log(subs) ~ log(citeprice), data = journals)
jour_lm <- lm(log(subs) ~ log(citeprice), data = journals)
summary(jour_lm)
abline(jour_lm)
data("SwissLabor")
?SwissLabor
?glm
swiss_probit <- glm(participation ~ . + I(age^2),
data = SwissLabor, family = binomial(link = "probit"))
summary(swiss_probit) # summary of results
plot(participation ~ age, data = SwissLabor, ylevels = 2:1)
favp <- mean(dnorm(predict(swiss_probit, type = "link")))
ape_p = favp * coef(swiss_probit) # these give the average partial effects
ape_p
swiss_logit <- glm(participation ~ . + I(age^2),
data = SwissLabor, family = binomial(link = "logit"))
summary(swiss_logit)
favl <- mean(dlogis(predict(swiss_logit, type = "link")))
ape_l = favl * coef(swiss_logit) # these give the average partial effects
ape_l
rbind(ape_p,ape_l)
data("RecreationDemand") # load data from AER package
rd_pois <- glm(trips ~ ., data = RecreationDemand,
family = poisson)
summary(rd_pois)
library("MASS") # this package is in-built. you don't need to install it
rd_nb <- glm.nb(trips ~ ., data = RecreationDemand)
summary(rd_nb)
